"""
ูุญุฏุฉ ูุนุงูุฌุฉ ุงูุนูุงูุฉ ุงููุงุฆูุฉ ููุตูุฑ ูุงูููุฏูููุงุช
ุชุฏุนู ุฅุถุงูุฉ ุนูุงูุฉ ูุงุฆูุฉ ูุตูุฉ ุฃู ุตูุฑุฉ ูุน ุฅุนุฏุงุฏุงุช ูุฎุตุตุฉ
"""
import os
import io
import logging
from PIL import Image, ImageDraw, ImageFont, ImageColor
import cv2
import numpy as np
from typing import Optional, Tuple, Union
import tempfile

logger = logging.getLogger(__name__)

class WatermarkProcessor:
    """ูุนุงูุฌ ุงูุนูุงูุฉ ุงููุงุฆูุฉ ููุตูุฑ ูุงูููุฏูููุงุช"""
    
    def __init__(self):
        """ุชููุฆุฉ ูุนุงูุฌ ุงูุนูุงูุฉ ุงููุงุฆูุฉ"""
        self.supported_image_formats = ['.jpg', '.jpeg', '.png', '.bmp', '.tiff', '.webp']
        self.supported_video_formats = ['.mp4', '.avi', '.mov', '.mkv', '.wmv', '.flv']
        
    def calculate_position(self, base_size: Tuple[int, int], watermark_size: Tuple[int, int], position: str, offset_x: int = 0, offset_y: int = 0) -> Tuple[int, int]:
        """ุญุณุงุจ ูููุน ุงูุนูุงูุฉ ุงููุงุฆูุฉ ุนูู ุงูุตูุฑุฉ/ุงูููุฏูู ูุน ุงูุฅุฒุงุญุฉ ุงููุฏููุฉ"""
        base_width, base_height = base_size
        watermark_width, watermark_height = watermark_size
        
        # ุชุญุฏูุฏ ุงููุงูุด (5% ูู ุญุฌู ุงูุตูุฑุฉ)
        margin = min(base_width, base_height) // 20
        
        position_map = {
            'top_left': (margin, margin),
            'top_right': (base_width - watermark_width - margin, margin),
            'top': ((base_width - watermark_width) // 2, margin),
            'bottom_left': (margin, base_height - watermark_height - margin),
            'bottom_right': (base_width - watermark_width - margin, base_height - watermark_height - margin),
            'bottom': ((base_width - watermark_width) // 2, base_height - watermark_height - margin),
            'center': ((base_width - watermark_width) // 2, (base_height - watermark_height) // 2)
        }
        
        base_position = position_map.get(position, position_map['bottom_right'])
        
        # ุฅุถุงูุฉ ุงูุฅุฒุงุญุฉ ุงููุฏููุฉ ูุน ุงูุชุฃูุฏ ูู ุงูุจูุงุก ุฏุงุฎู ุญุฏูุฏ ุงูุตูุฑุฉ
        final_x = max(0, min(base_position[0] + offset_x, base_width - watermark_width))
        final_y = max(0, min(base_position[1] + offset_y, base_height - watermark_height))
        
        logger.info(f"๐ ุงููููุน ุงูุฃุณุงุณู: {base_position}, ุงูุฅุฒุงุญุฉ: ({offset_x}, {offset_y}), ุงููููุน ุงูููุงุฆู: ({final_x}, {final_y})")
        
        return (final_x, final_y)
    
    def create_text_watermark(self, text: str, font_size: int, color: str, opacity: int, 
                            image_size: Tuple[int, int]) -> Image.Image:
        """ุฅูุดุงุก ุนูุงูุฉ ูุงุฆูุฉ ูุตูุฉ"""
        try:
            # ุฅูุดุงุก ุตูุฑุฉ ุดูุงูุฉ ูููุต
            img_width, img_height = image_size
            
            # ุญุณุงุจ ุญุฌู ุงูุฎุท ุจูุงุกู ุนูู ุญุฌู ุงูุตูุฑุฉ
            calculated_font_size = max(font_size, img_width // 25)  # ุฒูุงุฏุฉ ุญุฌู ุงูุฎุท
            
            # ูุญุงููุฉ ุงุณุชุฎุฏุงู ุฎุท ุนุฑุจู ุฅุฐุง ุฃููู
            font = None
            try:
                # ุงูุจุญุซ ุนู ุฎุท ุนุฑุจู ูู ุงููุธุงู
                font_paths = [
                    "/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf",
                    "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
                    "/System/Library/Fonts/Arial.ttf",
                    "arial.ttf"
                ]
                
                for font_path in font_paths:
                    if os.path.exists(font_path):
                        font = ImageFont.truetype(font_path, calculated_font_size)
                        break
            except Exception:
                pass
            
            if font is None:
                font = ImageFont.load_default()
            
            # ุญุณุงุจ ุญุฌู ุงููุต
            dummy_img = Image.new('RGBA', (1, 1))
            dummy_draw = ImageDraw.Draw(dummy_img)
            text_bbox = dummy_draw.textbbox((0, 0), text, font=font)
            text_width = text_bbox[2] - text_bbox[0]
            text_height = text_bbox[3] - text_bbox[1]
            
            # ุฅูุดุงุก ุตูุฑุฉ ูููุต ูุน ุฎูููุฉ ุดูุงูุฉ
            text_img = Image.new('RGBA', (int(text_width + 20), int(text_height + 10)), (0, 0, 0, 0))
            text_draw = ImageDraw.Draw(text_img)
            
            # ุชุญููู ุงูููู ุฅูู RGBA ูุน ุงูุดูุงููุฉ
            try:
                if color.startswith('#'):
                    rgb_color = ImageColor.getcolor(color, "RGB")
                    rgba_color = rgb_color + (int(255 * opacity / 100),)
                else:
                    rgba_color = (255, 255, 255, int(255 * opacity / 100))
            except Exception:
                rgba_color = (255, 255, 255, int(255 * opacity / 100))
            
            # ุฑุณู ุงููุต
            text_draw.text((10, 5), text, font=font, fill=rgba_color)
            
            return text_img
            
        except Exception as e:
            logger.error(f"ุฎุทุฃ ูู ุฅูุดุงุก ุงูุนูุงูุฉ ุงููุงุฆูุฉ ุงููุตูุฉ: {e}")
            return None
    
    def calculate_smart_watermark_size(self, base_image_size: Tuple[int, int], watermark_size: Tuple[int, int], 
                                     size_percentage: int, position: str = 'bottom_right') -> Tuple[int, int]:
        """ุญุณุงุจ ุญุฌู ุงูุนูุงูุฉ ุงููุงุฆูุฉ ุงูุฐูู ุญุณุจ ุฃุจุนุงุฏ ุงูุตูุฑุฉ ูุงูููุถุน"""
        base_width, base_height = base_image_size
        watermark_width, watermark_height = watermark_size
        
        # ุงูุญูุงุธ ุนูู ุงููุณุจุฉ ุงูุฃุตููุฉ ููุนูุงูุฉ ุงููุงุฆูุฉ
        aspect_ratio = watermark_width / watermark_height
        
        # ุญุณุงุจ ุงูุญุฌู ุจูุงุกู ุนูู ุงููุณุจุฉ ุงููุฆููุฉ ุงููุทููุจุฉ
        scale_factor = size_percentage / 100.0
        
        if size_percentage == 100:
            # ููุญุฌู 100%ุ ุงุณุชุฎุฏู ูุงูู ุฃุจุนุงุฏ ุงูุตูุฑุฉ ุงูุฃุณุงุณูุฉ ูุน ูุงูุด ุตุบูุฑ ููุท
            new_width = int(base_width * 0.98)  # 98% ูุชุฑู ูุงูุด ุตุบูุฑ ุฌุฏุงู
            new_height = int(base_height * 0.98)  # 98% ูุชุฑู ูุงูุด ุตุบูุฑ ุฌุฏุงู
            
            # ุงูุญูุงุธ ุนูู ุงููุณุจุฉ ุฅุฐุง ุฃูููุ ูุฅูุง ุงุณุชุฎุฏู ุงูุญุฌู ุงููุงูู
            calculated_height_from_width = int(new_width / aspect_ratio)
            calculated_width_from_height = int(new_height * aspect_ratio)
            
            # ุงุฎุชุฑ ุงูุญุฌู ุงูุฐู ูุญูู ุฃูุตู ุงุณุชูุงุฏุฉ ูู ุงููุณุงุญุฉ
            if calculated_height_from_width <= new_height:
                # ูููู ุงุณุชุฎุฏุงู ุงูุนุฑุถ ุงููุงูู
                new_height = calculated_height_from_width
            else:
                # ุงุณุชุฎุฏู ุงูุงุฑุชูุงุน ุงููุงูู ูุญุณุงุจ ุงูุนุฑุถ
                new_width = calculated_width_from_height
                
            logger.info(f"๐ฏ ุญุฌู 100%: ุฃุจุนุงุฏ ุงูุตูุฑุฉ {base_image_size} โ ุฃุจุนุงุฏ ุงูุนูุงูุฉ {(new_width, new_height)}")
        else:
            # ูููุณุจ ุงููุฆููุฉ ุงูุฃุฎุฑูุ ุญุณุงุจ ุนุงุฏู
            if position in ['top', 'bottom', 'center']:
                # ููููุงุถุน ุงูุฃูููุฉุ ุงุณุชุฎุฏู ุงููุณุจุฉ ุงููุฆููุฉ ูุงููุฉ ูู ุงูุนุฑุถ
                new_width = int(base_width * scale_factor)
            else:
                # ููููุงุถุน ุงูุฑูููุฉุ ุงุณุชุฎุฏู ูุณุจุฉ ูุนุฏูุฉ
                new_width = int(base_width * scale_factor * 0.8)
            
            new_height = int(new_width / aspect_ratio)
            
            # ุชุทุจูู ุญุฏูุฏ ูุนูููุฉ ููุฃุญุฌุงู ุงูุฃุฎุฑู
            max_allowed_width = base_width * 0.9  
            max_allowed_height = base_height * 0.7
            
            if new_width > max_allowed_width:
                new_width = int(max_allowed_width)
                new_height = int(new_width / aspect_ratio)
                
            if new_height > max_allowed_height:
                new_height = int(max_allowed_height)
                new_width = int(new_height * aspect_ratio)
        
        # ุชุฃูุฏ ูู ุงูุญุฏ ุงูุฃุฏูู ููุญุฌู
        min_size = 20
        new_width = max(min_size, new_width)
        new_height = max(min_size, new_height)
        
        # ุชุฃูุฏ ูู ุนุฏู ุชุฌุงูุฒ ุฃุจุนุงุฏ ุงูุตูุฑุฉ ุงูุฃุณุงุณูุฉ
        new_width = min(new_width, base_width - 10)  # ูุงูุด 10 ุจูุณู
        new_height = min(new_height, base_height - 10)  # ูุงูุด 10 ุจูุณู
        
        logger.info(f"๐ ุญุณุงุจ ุญุฌู ุงูุนูุงูุฉ ุงููุงุฆูุฉ: {size_percentage}% โ {(new_width, new_height)} ูู ุฃุตู {base_image_size}")
        
        return (new_width, new_height)

    def load_image_watermark(self, image_path: str, size_percentage: int, opacity: int,
                           base_image_size: Tuple[int, int], position: str = 'bottom_right') -> Optional[Image.Image]:
        """ุชุญููู ูุชุญุถูุฑ ุนูุงูุฉ ูุงุฆูุฉ ูู ุตูุฑุฉ ุจุญุฌู ุฐูู"""
        try:
            if not os.path.exists(image_path):
                logger.error(f"ููู ุงูุตูุฑุฉ ุบูุฑ ููุฌูุฏ: {image_path}")
                return None
            
            # ุชุญููู ุงูุตูุฑุฉ
            watermark_img = Image.open(image_path)
            
            # ุชุญููู ุฅูู RGBA ููุฏุนู ุงูุดูุงููุฉ
            if watermark_img.mode != 'RGBA':
                watermark_img = watermark_img.convert('RGBA')
            
            # ุญุณุงุจ ุงูุญุฌู ุงูุฐูู
            original_size = watermark_img.size
            smart_size = self.calculate_smart_watermark_size(base_image_size, original_size, size_percentage, position)
            
            logger.info(f"๐ ุชุญุฌูู ุงูุนูุงูุฉ ุงููุงุฆูุฉ ุงูุฐูู: {original_size} โ {smart_size}")
            logger.info(f"๐ฏ ุฅุนุฏุงุฏุงุช: ูุณุจุฉ {size_percentage}%, ููุถุน {position}, ุฃุจุนุงุฏ ุงูุตูุฑุฉ {base_image_size}")
            
            # ุชุบููุฑ ุญุฌู ุงูุตูุฑุฉ
            watermark_img = watermark_img.resize(smart_size, Image.Resampling.LANCZOS)
            
            # ุชุทุจูู ุงูุดูุงููุฉ
            if opacity < 100:
                alpha = watermark_img.split()[-1]
                alpha = alpha.point(lambda p: int(p * opacity / 100))
                watermark_img.putalpha(alpha)
            
            return watermark_img
            
        except Exception as e:
            logger.error(f"ุฎุทุฃ ูู ุชุญููู ุตูุฑุฉ ุงูุนูุงูุฉ ุงููุงุฆูุฉ: {e}")
            return None
    
    def apply_watermark_to_image(self, image_bytes: bytes, watermark_settings: dict) -> Optional[bytes]:
        """ุชุทุจูู ุงูุนูุงูุฉ ุงููุงุฆูุฉ ุนูู ุตูุฑุฉ"""
        try:
            # ุชุญููู ุงูุตูุฑุฉ
            image = Image.open(io.BytesIO(image_bytes))
            
            # ุชุญููู ุฅูู RGB ุฅุฐุง ูุฒู ุงูุฃูุฑ
            if image.mode not in ['RGB', 'RGBA']:
                image = image.convert('RGB')
            
            # ุฅูุดุงุก ุงูุนูุงูุฉ ุงููุงุฆูุฉ
            watermark = None
            
            if watermark_settings['watermark_type'] == 'text' and watermark_settings['watermark_text']:
                color = watermark_settings['text_color'] if not watermark_settings['use_original_color'] else '#FFFFFF'
                watermark = self.create_text_watermark(
                    watermark_settings['watermark_text'],
                    watermark_settings['font_size'],
                    color,
                    watermark_settings['opacity'],
                    image.size
                )
            
            elif watermark_settings['watermark_type'] == 'image' and watermark_settings['watermark_image_path']:
                watermark = self.load_image_watermark(
                    watermark_settings['watermark_image_path'],
                    watermark_settings['size_percentage'],
                    watermark_settings['opacity'],
                    image.size,
                    watermark_settings.get('position', 'bottom_right')
                )
            
            if watermark is None:
                logger.warning("ูุดู ูู ุฅูุดุงุก ุงูุนูุงูุฉ ุงููุงุฆูุฉ")
                return image_bytes
            
            # ุญุณุงุจ ูููุน ุงูุนูุงูุฉ ุงููุงุฆูุฉ ูุน ุงูุฅุฒุงุญุฉ ุงููุฏููุฉ
            offset_x = watermark_settings.get('offset_x', 0)
            offset_y = watermark_settings.get('offset_y', 0)
            position = self.calculate_position(image.size, watermark.size, watermark_settings['position'], offset_x, offset_y)
            
            # ุชุทุจูู ุงูุนูุงูุฉ ุงููุงุฆูุฉ
            if image.mode == 'RGBA':
                image.paste(watermark, position, watermark)
            else:
                # ุชุญููู ุฅูู RGBA ูุชุทุจูู ุงูุนูุงูุฉ ุงููุงุฆูุฉ
                image = image.convert('RGBA')
                image.paste(watermark, position, watermark)
                # ุชุญููู ูุฑุฉ ุฃุฎุฑู ุฅูู RGB
                image = image.convert('RGB')
            
            # ุญูุธ ุงูุตูุฑุฉ ุจุชูุณูููุง ุงูุฃุตูู ุฃู PNG ููุญูุงุธ ุนูู ุงูุฌูุฏุฉ
            output = io.BytesIO()
            
            # ุชุญุฏูุฏ ุชูุณูู ุงูุญูุธ ุจูุงุกู ุนูู ุงูุตูุฑุฉ ุงูุฃุตููุฉ
            try:
                original_image = Image.open(io.BytesIO(image_bytes))
                original_format = original_image.format or 'PNG'
                
                # ุงุณุชุฎุฏุงู PNG ููุตูุฑ ุงูุชู ุชุญุชูู ุนูู ุดูุงููุฉ
                if image.mode == 'RGBA' or original_format == 'PNG':
                    image.save(output, format='PNG', optimize=True)
                elif original_format in ['JPEG', 'JPG']:
                    # ุชุญููู RGBA ุฅูู RGB ููู JPEG
                    if image.mode == 'RGBA':
                        background = Image.new('RGB', image.size, (255, 255, 255))
                        background.paste(image, mask=image.split()[-1])
                        image = background
                    image.save(output, format='JPEG', quality=95, optimize=True)
                else:
                    # ุงุณุชุฎุฏุงู PNG ูุชูุณูู ุงูุชุฑุงุถู
                    image.save(output, format='PNG', optimize=True)
            except Exception:
                # ูู ุญุงูุฉ ูุดู ุชุญุฏูุฏ ุงูุชูุณููุ ุงุณุชุฎุฏู PNG
                image.save(output, format='PNG', optimize=True)
                
            return output.getvalue()
            
        except Exception as e:
            logger.error(f"ุฎุทุฃ ูู ุชุทุจูู ุงูุนูุงูุฉ ุงููุงุฆูุฉ ุนูู ุงูุตูุฑุฉ: {e}")
            return image_bytes
    
    def apply_watermark_to_video(self, video_path: str, watermark_settings: dict) -> Optional[str]:
        """ุชุทุจูู ุงูุนูุงูุฉ ุงููุงุฆูุฉ ุนูู ููุฏูู"""
        try:
            # ูุชุญ ุงูููุฏูู
            cap = cv2.VideoCapture(video_path)
            if not cap.isOpened():
                logger.error(f"ูุดู ูู ูุชุญ ุงูููุฏูู: {video_path}")
                return None
            
            # ุงูุญุตูู ุนูู ุฎุตุงุฆุต ุงูููุฏูู
            fps = int(cap.get(cv2.CAP_PROP_FPS))
            width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
            height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
            total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
            
            # ุฅูุดุงุก ููู ูุคูุช ููููุฏูู ุงูุฌุฏูุฏ
            temp_dir = tempfile.gettempdir()
            output_path = os.path.join(temp_dir, f"watermarked_{os.path.basename(video_path)}")
            
            # ุฅุนุฏุงุฏ ูุงุชุจ ุงูููุฏูู
            fourcc = cv2.VideoWriter.fourcc(*'mp4v')
            out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))
            
            # ุชุญุถูุฑ ุงูุนูุงูุฉ ุงููุงุฆูุฉ
            watermark_img = None
            
            if watermark_settings['watermark_type'] == 'text' and watermark_settings['watermark_text']:
                color = watermark_settings['text_color'] if not watermark_settings['use_original_color'] else '#FFFFFF'
                watermark_pil = self.create_text_watermark(
                    watermark_settings['watermark_text'],
                    watermark_settings['font_size'],
                    color,
                    watermark_settings['opacity'],
                    (width, height)
                )
                if watermark_pil:
                    watermark_img = cv2.cvtColor(np.array(watermark_pil), cv2.COLOR_RGBA2BGRA)
            
            elif watermark_settings['watermark_type'] == 'image' and watermark_settings['watermark_image_path']:
                watermark_pil = self.load_image_watermark(
                    watermark_settings['watermark_image_path'],
                    watermark_settings['size_percentage'],
                    watermark_settings['opacity'],
                    (width, height),
                    watermark_settings.get('position', 'bottom_right')
                )
                if watermark_pil:
                    watermark_img = cv2.cvtColor(np.array(watermark_pil), cv2.COLOR_RGBA2BGRA)
            
            if watermark_img is None:
                cap.release()
                out.release()
                return video_path
            
            # ุญุณุงุจ ูููุน ุงูุนูุงูุฉ ุงููุงุฆูุฉ ูุน ุงูุฅุฒุงุญุฉ ุงููุฏููุฉ
            watermark_height, watermark_width = watermark_img.shape[:2]
            offset_x = watermark_settings.get('offset_x', 0)
            offset_y = watermark_settings.get('offset_y', 0)
            position = self.calculate_position((width, height), (watermark_width, watermark_height), watermark_settings['position'], offset_x, offset_y)
            x, y = position
            
            # ูุนุงูุฌุฉ ูู ุฅุทุงุฑ
            frame_count = 0
            while True:
                ret, frame = cap.read()
                if not ret:
                    break
                
                # ุชุทุจูู ุงูุนูุงูุฉ ุงููุงุฆูุฉ ุนูู ุงูุฅุทุงุฑ
                try:
                    # ุฅูุดุงุก ููุงุน ููุนูุงูุฉ ุงููุงุฆูุฉ
                    alpha = watermark_img[:, :, 3] / 255.0
                    
                    # ุชุทุจูู ุงูุนูุงูุฉ ุงููุงุฆูุฉ
                    for c in range(0, 3):
                        frame[y:y+watermark_height, x:x+watermark_width, c] = (
                            alpha * watermark_img[:, :, c] + 
                            (1 - alpha) * frame[y:y+watermark_height, x:x+watermark_width, c]
                        )
                except Exception as e:
                    logger.warning(f"ุฎุทุฃ ูู ุชุทุจูู ุงูุนูุงูุฉ ุงููุงุฆูุฉ ุนูู ุงูุฅุทุงุฑ {frame_count}: {e}")
                
                # ูุชุงุจุฉ ุงูุฅุทุงุฑ
                out.write(frame)
                frame_count += 1
                
                # ุฅุธูุงุฑ ุงูุชูุฏู ูู 100 ุฅุทุงุฑ
                if frame_count % 100 == 0:
                    progress = (frame_count / total_frames) * 100
                    logger.info(f"ูุนุงูุฌุฉ ุงูููุฏูู: {progress:.1f}% ({frame_count}/{total_frames})")
            
            # ุฅุบูุงู ุงููููุงุช
            cap.release()
            out.release()
            
            logger.info(f"ุชู ุชุทุจูู ุงูุนูุงูุฉ ุงููุงุฆูุฉ ุนูู ุงูููุฏูู: {output_path}")
            return output_path
            
        except Exception as e:
            logger.error(f"ุฎุทุฃ ูู ุชุทุจูู ุงูุนูุงูุฉ ุงููุงุฆูุฉ ุนูู ุงูููุฏูู: {e}")
            return None
    
    def should_apply_watermark(self, media_type: str, watermark_settings: dict) -> bool:
        """ุชุญุฏูุฏ ูุง ุฅุฐุง ูุงู ูุฌุจ ุชุทุจูู ุงูุนูุงูุฉ ุงููุงุฆูุฉ ุนูู ููุน ุงููุณุงุฆุท"""
        if not watermark_settings.get('enabled', False):
            return False
        
        if media_type == 'photo' and not watermark_settings.get('apply_to_photos', True):
            return False
        
        if media_type == 'video' and not watermark_settings.get('apply_to_videos', True):
            return False
        
        if media_type == 'document' and not watermark_settings.get('apply_to_documents', False):
            return False
        
        return True
    
    def get_media_type_from_file(self, file_path: str) -> str:
        """ุชุญุฏูุฏ ููุน ุงููุณุงุฆุท ูู ุงูุชุฏุงุฏ ุงูููู"""
        ext = os.path.splitext(file_path.lower())[1]
        
        if ext in self.supported_image_formats:
            return 'photo'
        elif ext in self.supported_video_formats:
            return 'video'
        else:
            return 'document'
    
    def process_media_with_watermark(self, media_bytes: bytes, file_name: str, watermark_settings: dict) -> Optional[bytes]:
        """ูุนุงูุฌุฉ ุงููุณุงุฆุท ูุชุทุจูู ุงูุนูุงูุฉ ุงููุงุฆูุฉ ุญุณุจ ุงูููุน"""
        try:
            media_type = self.get_media_type_from_file(file_name)
            
            if not self.should_apply_watermark(media_type, watermark_settings):
                return media_bytes
            
            if media_type == 'photo':
                return self.apply_watermark_to_image(media_bytes, watermark_settings)
            
            elif media_type == 'video':
                # ุญูุธ ุงูููุฏูู ูุคูุชุงู
                temp_input = tempfile.NamedTemporaryFile(delete=False, suffix=os.path.splitext(file_name)[1])
                temp_input.write(media_bytes)
                temp_input.close()
                
                # ุชุทุจูู ุงูุนูุงูุฉ ุงููุงุฆูุฉ
                watermarked_path = self.apply_watermark_to_video(temp_input.name, watermark_settings)
                
                if watermarked_path and os.path.exists(watermarked_path):
                    # ูุฑุงุกุฉ ุงูููุฏูู ุงููุนุงูุฌ
                    with open(watermarked_path, 'rb') as f:
                        watermarked_bytes = f.read()
                    
                    # ุญุฐู ุงููููุงุช ุงููุคูุชุฉ
                    os.unlink(temp_input.name)
                    os.unlink(watermarked_path)
                    
                    return watermarked_bytes
                else:
                    os.unlink(temp_input.name)
                    return media_bytes
            
            else:
                # ููุน ูุณุงุฆุท ุบูุฑ ูุฏุนูู ููุนูุงูุฉ ุงููุงุฆูุฉ
                return media_bytes
                
        except Exception as e:
            logger.error(f"ุฎุทุฃ ูู ูุนุงูุฌุฉ ุงููุณุงุฆุท ุจุงูุนูุงูุฉ ุงููุงุฆูุฉ: {e}")
            return media_bytes